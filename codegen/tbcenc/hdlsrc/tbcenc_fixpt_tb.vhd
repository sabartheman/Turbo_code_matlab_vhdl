-- -------------------------------------------------------------
-- 
-- File Name: /home/sky/Documents/MATLAB/Turbo_codes/codegen/tbcenc/hdlsrc/tbcenc_fixpt_tb.vhd
-- Created: 2019-04-08 16:00:07
-- 
-- Generated by MATLAB 9.5, MATLAB Coder 4.1 and HDL Coder 3.13
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: tbcenc_fixpt_tb
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_textio.ALL;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
LIBRARY STD;
USE STD.textio.ALL;
LIBRARY work;
USE work.tbcenc_fixpt_pkg.ALL;
USE work.tbcenc_fixpt_tb_pkg.ALL;

ENTITY tbcenc_fixpt_tb IS
END tbcenc_fixpt_tb;


ARCHITECTURE rtl OF tbcenc_fixpt_tb IS

  -- Component Declarations
  COMPONENT tbcenc_fixpt
    PORT( msg_in                          :   IN    std_logic_vector(0 TO 7);  -- ufix1 [8]
          intlv                           :   IN    vector_of_std_logic_vector4(0 TO 7);  -- ufix4 [8]
          output1                         :   OUT   std_logic_vector(0 TO 7);  -- boolean [8]
          output2                         :   OUT   std_logic_vector(0 TO 7);  -- boolean [8]
          output3                         :   OUT   std_logic_vector(0 TO 7)  -- boolean [8]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : tbcenc_fixpt
    USE ENTITY work.tbcenc_fixpt(rtl);

  -- Signals
  SIGNAL clk                              : std_logic;
  SIGNAL reset                            : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL output1_addr                     : std_logic;  -- ufix1
  SIGNAL output1_lastAddr                 : std_logic;  -- ufix1
  SIGNAL output2_addr                     : std_logic;  -- ufix1
  SIGNAL output2_lastAddr                 : std_logic;  -- ufix1
  SIGNAL output3_addr                     : std_logic;  -- ufix1
  SIGNAL output3_lastAddr                 : std_logic;  -- ufix1
  SIGNAL output3_done                     : std_logic;  -- ufix1
  SIGNAL rdEnb                            : std_logic;
  SIGNAL output3_done_enb                 : std_logic;  -- ufix1
  SIGNAL resetn                           : std_logic;
  SIGNAL check3_done                      : std_logic;  -- ufix1
  SIGNAL output2_done                     : std_logic;  -- ufix1
  SIGNAL output2_done_enb                 : std_logic;  -- ufix1
  SIGNAL check2_done                      : std_logic;  -- ufix1
  SIGNAL snkDone                          : std_logic;
  SIGNAL snkDonen                         : std_logic;
  SIGNAL tb_enb                           : std_logic;
  SIGNAL output1_done                     : std_logic;  -- ufix1
  SIGNAL output1_done_enb                 : std_logic;  -- ufix1
  SIGNAL check1_done                      : std_logic;  -- ufix1
  SIGNAL ce_out                           : std_logic;
  SIGNAL rawData_msg_in                   : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL holdData_msg_in                  : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL rawData_intlv                    : vector_of_unsigned4(0 TO 7);  -- ufix4 [8]
  SIGNAL holdData_intlv                   : vector_of_unsigned4(0 TO 7);  -- ufix4 [8]
  SIGNAL msg_in_offset                    : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL msg_in_1                         : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL intlv_offset                     : vector_of_unsigned4(0 TO 7);  -- ufix4 [8]
  SIGNAL intlv_1                          : vector_of_unsigned4(0 TO 7);  -- ufix4 [8]
  SIGNAL intlv_2                          : vector_of_std_logic_vector4(0 TO 7);  -- ufix4 [8]
  SIGNAL output1                          : std_logic_vector(0 TO 7);  -- boolean [8]
  SIGNAL output2                          : std_logic_vector(0 TO 7);  -- boolean [8]
  SIGNAL output3                          : std_logic_vector(0 TO 7);  -- boolean [8]
  SIGNAL output1_expected_1               : std_logic_vector(0 TO 7);  -- boolean [8]
  SIGNAL output1_ref                      : std_logic_vector(0 TO 7);  -- boolean [8]
  SIGNAL output1_testFailure              : std_logic;  -- ufix1
  SIGNAL output2_expected_1               : std_logic_vector(0 TO 7);  -- boolean [8]
  SIGNAL output2_ref                      : std_logic_vector(0 TO 7);  -- boolean [8]
  SIGNAL output2_testFailure              : std_logic;  -- ufix1
  SIGNAL output3_expected_1               : std_logic_vector(0 TO 7);  -- boolean [8]
  SIGNAL output3_ref                      : std_logic_vector(0 TO 7);  -- boolean [8]
  SIGNAL output3_testFailure              : std_logic;  -- ufix1
  SIGNAL testFailure                      : std_logic;  -- ufix1

BEGIN
  u_tbcenc_fixpt : tbcenc_fixpt
    PORT MAP( msg_in => msg_in_1,  -- ufix1 [8]
              intlv => intlv_2,  -- ufix4 [8]
              output1 => output1,  -- boolean [8]
              output2 => output2,  -- boolean [8]
              output3 => output3  -- boolean [8]
              );

  output1_lastAddr <= '1';

  output2_lastAddr <= '1';

  output3_lastAddr <= '1';

  output3_done_enb <= output3_done AND rdEnb;

  output3_done <= output3_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check3_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF output3_done_enb = '1' THEN
        check3_done <= output3_done;
      END IF;
    END IF;
  END PROCESS checkDone_3_process;

  output2_done_enb <= output2_done AND rdEnb;

  output2_done <= output2_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check2_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF output2_done_enb = '1' THEN
        check2_done <= output2_done;
      END IF;
    END IF;
  END PROCESS checkDone_2_process;

  snkDonen <=  NOT snkDone;

  tb_enb <= resetn AND snkDonen;

  
  rdEnb <= tb_enb WHEN snkDone = '0' ELSE
      '0';

  output1_done_enb <= output1_done AND rdEnb;

  clk_gen: PROCESS 
  BEGIN
    clk <= '1';
    WAIT FOR 5 ns;
    clk <= '0';
    WAIT FOR 5 ns;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR 5 ns;
      clk <= '0';
      WAIT FOR 5 ns;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  reset_gen: PROCESS 
  BEGIN
    reset <= '1';
    WAIT FOR 20 ns;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR 2 ns;
    reset <= '0';
    WAIT;
  END PROCESS reset_gen;

  resetn <=  NOT reset;

  output1_done <= output1_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check1_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF output1_done_enb = '1' THEN
        check1_done <= output1_done;
      END IF;
    END IF;
  END PROCESS checkDone_1_process;

  snkDone <= check3_done AND (check1_done AND check2_done);

  enb <= rdEnb AFTER 2 ns;

  ce_out <= enb AND (rdEnb AND tb_enb);

  -- Data source for msg_in
  rawData_msg_in(0) <= '1';
  rawData_msg_in(1) <= '0';
  rawData_msg_in(2) <= '1';
  rawData_msg_in(3) <= '0';
  rawData_msg_in(4) <= '1';
  rawData_msg_in(5) <= '1';
  rawData_msg_in(6) <= '0';
  rawData_msg_in(7) <= '0';

  -- holdData reg for msg_in
  stimuli_msg_in_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_msg_in <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_msg_in <= rawData_msg_in;
    END IF;
  END PROCESS stimuli_msg_in_process;

  -- Data source for intlv
  rawData_intlv(0) <= to_unsigned(16#5#, 4);
  rawData_intlv(1) <= to_unsigned(16#6#, 4);
  rawData_intlv(2) <= to_unsigned(16#8#, 4);
  rawData_intlv(3) <= to_unsigned(16#4#, 4);
  rawData_intlv(4) <= to_unsigned(16#2#, 4);
  rawData_intlv(5) <= to_unsigned(16#1#, 4);
  rawData_intlv(6) <= to_unsigned(16#7#, 4);
  rawData_intlv(7) <= to_unsigned(16#3#, 4);

  -- holdData reg for intlv
  stimuli_intlv_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_intlv <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_intlv <= rawData_intlv;
    END IF;
  END PROCESS stimuli_intlv_process;

  stimuli_msg_in_1: PROCESS (rawData_msg_in, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      msg_in_offset <= holdData_msg_in;
    ELSE
      msg_in_offset <= rawData_msg_in;
    END IF;
  END PROCESS stimuli_msg_in_1;

  msg_in_1 <= msg_in_offset AFTER 2 ns;

  stimuli_intlv_1: PROCESS (rawData_intlv, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      intlv_offset <= holdData_intlv;
    ELSE
      intlv_offset <= rawData_intlv;
    END IF;
  END PROCESS stimuli_intlv_1;

  intlv_1 <= intlv_offset AFTER 2 ns;

  outputgen: FOR k IN 0 TO 7 GENERATE
    intlv_2(k) <= std_logic_vector(intlv_1(k));
  END GENERATE;

  -- Data source for output1_expected
  output1_expected_1(0) <= '1';
  output1_expected_1(1) <= '0';
  output1_expected_1(2) <= '1';
  output1_expected_1(3) <= '0';
  output1_expected_1(4) <= '1';
  output1_expected_1(5) <= '1';
  output1_expected_1(6) <= '0';
  output1_expected_1(7) <= '0';

  output1_ref <= output1_expected_1;

  output1_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      output1_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND output1 /= output1_ref THEN
        output1_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in output1: Expected " & to_hex(output1_ref) & (" Actual " & to_hex(output1))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS output1_checker;

  -- Data source for output2_expected
  output2_expected_1(0) <= '1';
  output2_expected_1(1) <= '1';
  output2_expected_1(2) <= '0';
  output2_expected_1(3) <= '1';
  output2_expected_1(4) <= '1';
  output2_expected_1(5) <= '1';
  output2_expected_1(6) <= '1';
  output2_expected_1(7) <= '1';

  output2_ref <= output2_expected_1;

  output2_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      output2_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND output2 /= output2_ref THEN
        output2_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in output2: Expected " & to_hex(output2_ref) & (" Actual " & to_hex(output2))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS output2_checker;

  -- Data source for output3_expected
  output3_expected_1(0) <= '1';
  output3_expected_1(1) <= '0';
  output3_expected_1(2) <= '0';
  output3_expected_1(3) <= '1';
  output3_expected_1(4) <= '1';
  output3_expected_1(5) <= '1';
  output3_expected_1(6) <= '0';
  output3_expected_1(7) <= '1';

  output3_ref <= output3_expected_1;

  output3_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      output3_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND output3 /= output3_ref THEN
        output3_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in output3: Expected " & to_hex(output3_ref) & (" Actual " & to_hex(output3))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS output3_checker;

  testFailure <= output3_testFailure OR (output1_testFailure OR output2_testFailure);

  completed_msg: PROCESS (clk)
  BEGIN
    IF clk'event AND clk = '1' THEN
      IF snkDone = '1' THEN
        IF testFailure = '0' THEN
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (PASSED)**************"
            SEVERITY NOTE;
        ELSE
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (FAILED)**************"
            SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

END rtl;

